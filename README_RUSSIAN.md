<h3 align="center">
Минеева Екатерина  <br />
НИУ ВШЭ ФКН БПМИ-152 <br />
Проект  <br />
</h3>
<h2 align="center">
«Семантическая сегментация изображений  <br />
для автоматической разметки аэрофотоснимков»  <br />
</h2>
<h3 align="center">
под руководством ментора Вадима Горбачёва
</h3>
 <br />

#### Постановка задачи

Проанализировать аэрофотоснимки и автоматизировать процесс классификации объектов, изображенных на снимке. 

В данном проекте анализируются высококачественные аэрофотоснимки немецких городов Vaihingen и Potsdam. Требуется отнести каждый пиксел изображения к одному из классов:

* Непрозрачные поверхности
* Здания
* Низкая растительность
* Деревья
* Машины
* Дорога/прочее

В данные предоставленные для обучения и тестирования входят:

* Исходные снимки
* TOP - синтезированный снимок из бесконечно удалённой точки
* DSM – карта высот объектов
* nDSM – карта высот объектов нормализованная относительно уровня земли 
* PAN – черно-белые снимки
* CII - инфракрасный канал

Кроме того для части снимков имеются Ground Truth изображения (размеченные вручную),что позволяет применить методы машинного обучения к данной задачи. На данный момент открыт [контест](http://www2.isprs.org/commissions/comm3/wg4/semantic-labeling.html), куда все желающие могут отправить свой алгоритм и посоревноваться с другими участниками. Некоторые участники достигли высокой точности в разметке снимков и опубликовали ряд статей по данной тематике. 

 <br />

#### План реализации проекта

1. Первая контрольная точка - 17 декабря 2016:
    * Изучение задачи, методов ее решения и постановка технического задания
    * Реализация пересегментации и оценка погрешности, которую она вносит
2. Вторая контрольная точка - 20-25 марта 2017:
    * Выделение различных признаков 
    * Обучение на их основе Random Forest 
    * Оценка полученных результатов
3. Третья контрольная точка - 29 мая - 3 июня
    * Обучение на основе Conditional random fields 
    * Использование Convolutional Neural Network 
    * Изучение статей и эксперименты со свежими результатами полученными в данной области.
    * Реализация полного функционала и подведение итогов.
    
    

<br />

#### Методы решения

Для решения данной задачи применяется метод машинного обучения, реализация состоит из нескольких шагов

1. Предварительная сегментация изображения на "суперпиксели" -- данный шаг обусловлен двумя факторами: во-первых, у аэрофотоснимков, которые предстоит анализировать, высокое разрешение, поэтому анализ каждого пиксела изображения потребовал бы очень больших мощностей, а, во-вторых, подобное решение не так эффективно, поскольку объекты, которые представлены на снимках имеют сравнительно большой размер, а характеристики каждого отдельного пиксела не так важны -- куда более информативен анализ в совокупности.
В качестве алгоритма, реализующего предварительную сегментацию был выбран SLIC (Simple Linear Iterative Clustering), поскольку:
    * ошибка, которую вносит пересегментация при помощи SLIC, минимальна: проверено эмпирически
    * сегменты, которые выделяет данный алгоритм, равномерно распределены по всему изображения и их размер не сильно различается

2. Признаки, по которым будет происходит анализ изображения
    * Среднее, максимум и дисперсия цветов и nDMS -- одни из самых простых и вместе с тем важных различий 
    * Координаты пикселей в других цветовых пространствах -- HSV, CIELab
    * Контекст - например, среднее по цветовым каналам соседних суперпикселей. Существенно увеличило информативность центрирование случайной величины "цвет соседа" и последующая ее нормировка, пропорциональная размеру области, по которой сегменты граничат
    * Результаты работы сверточной нейронной сети (CNN) в качестве признаков.
    * Вероятность принадлежности к каждому из классов 
    * Вероятность пары классов оказаться по соседству
    
    (Однако найти полноценное применение последним двум пунктам пока не вышло -- значительного улучшения  результатов не наблюдалось)

3. В качестве классификатора был опробован Random Forest -- такой выбор был сделан в силу простоты и удобства использования. Его работа стабильна и позволяет оценить значимость признаков, что немаловажно. Также использовался Conditional random fields -- более эффективный, но вместе с тем и более сложный в применении. Этот классификатор показал хорошие результаты, а также приятно удивил быстротой своей работы.

На данный момент результаты сегментации уже достаточно неплохие, чтобы продвинуться намного дальше результатов 2 контрольной точки нужно владеть областью на совсем другом уровне. Изучение различных подходов к сегментации было очень интресным, однако воплотить в жизнь самые продвинутые и эффективные алгоритмы не удалось.
    
 <br />

#### Архитектура программного продукта

Мой проект разбит на небольшие блоки:

presegmentation -- на этом уровне происходит разбиение на супер-пиксели
features -- в этой части происходит выделение признаков -- пожалуй, наиболее обширный и разнообразный раздел проекта
classifier -- основные функции этого раздела: learn и classify, названия говорят сами за себя
accuracy_evaluation -- вычисление различных метрик, чтобы наиболее полно оценить качество сегментации

И, наконец, main, в котором все эти части собираются воедино. Также есть раздел, который называется namespace -- сначала он и был пространством имен, но как-то очень уж разросся в итоге -- там собраны довольно технические функции, упрощающие чтение/запись данных и прочие "подсобные" функции и переменные.

 <br />

#### Инструкции по запуску:

Чтобы запустить процесс обучения, достаточно вызвать функцию main, подав ей в качестве аргумента, два массива из номеров тех фотографий, которые были выбраны в качестве обучающей выборки и тестовой выборки соответственно. (Обратите внимание, что программа работает в предположении, что в рабочей директории находятся папки gts, top, ndsm с соответствующим содержанием). По окончании работы функция выведет на экран численные результаты сегментации, а также в папке "classified" будут находиться размеченные программой снимки.
Однако, вычисление всех признаков -- дело не быстрое, так что достаточно посчитать их один раз, а потом просто закомментировать код при необходимости.
